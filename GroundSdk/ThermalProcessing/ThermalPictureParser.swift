//    Copyright (C) 2019 Parrot Drones SAS
//
//    Redistribution and use in source and binary forms, with or without
//    modification, are permitted provided that the following conditions
//    are met:
//    * Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in
//      the documentation and/or other materials provided with the
//      distribution.
//    * Neither the name of the Parrot Company nor the names
//      of its contributors may be used to endorse or promote products
//      derived from this software without specific prior written
//      permission.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//    PARROT COMPANY BE LIABLE FOR ANY DIRECT, INDIRECT,
//    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
//    OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
//    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
//    OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
//    SUCH DAMAGE.

import Foundation

/// Parser of thermal pictures.
///
/// Enable parsing of thermal pictures generated by drones and creation of 'ThermalPicture'
/// instances that can be used by TPRoc for rendering.
public class ThermalPictureParser {

    /// Log tag.
    static let TprocTag = ULogTag(name: "ff.tproc")

    /// Common first byte of segments markers.
    private static let MARKER_COMMON: UInt8  = 0xFF
    /// Start of image marker.
    private static let MARKER_SOI:  UInt8 = 0xD8
    /// End of image marker.
    private static let MARKER_EOI:  UInt8 = 0xD9
    /// Synchronization marker.
    private static let MARKER_RST0: UInt8 = 0xD0
    /// Synchronization marker.
    private static let MARKER_RST1: UInt8 = 0xD1
    /// Synchronization marker.
    private static let MARKER_RST2: UInt8 = 0xD2
    /// Synchronization marker.
    private static let MARKER_RST3: UInt8 = 0xD3
    /// Synchronization marker.
    private static let MARKER_RST4: UInt8 = 0xD4
    /// Synchronization marker.
    private static let MARKER_RST5: UInt8 = 0xD5
    /// Synchronization marker.
    private static let MARKER_RST6: UInt8 = 0xD6
    /// Synchronization marker.
    private static let MARKER_RST7: UInt8 = 0xD7
    /// Application 1 marker.
    private static let MARKER_APP1: UInt8 = 0xE1

    /// Identifier of Parrot visible data in APP1 segments.
    private static let TOKEN_PARROT_VISIBLE = Data("PARV".utf8)
    /// Identifier of Parrot thermal data in APP1 segments.
    private static let TOKEN_PARROT_THERMAL = Data("PART".utf8)
    /// Identifier of FLIR data in APP1 segments.
    private static let TOKEN_FLIR = Data("FLIR".utf8)
    /// Identifier of XMP data in APP1 segments.
    private static let TOKEN_XMP = Data("http://ns.adobe.com/xap/1.0/\0".utf8)

    /// Read content of a thermal picture generated by a drone and create a 'ThermalPicture' object.
    ///
    /// - Parameter file: thermal picture file
    /// - Returns: a 'ThermalPicture' instance on success, 'nil' otherwise
    public static func createPicture(file: URL) -> ThermalProcPictureData? {
        // jpeg data of visible image
        var visibleData: Data = Data()
        // TIFF data containing thermal data
        var tiffData: Data = Data()
        // thermal data
        var thermalData: Data = Data()
        // FLIR data
        var flirData: Data = Data()
        // parsed XMP parameters: format version and camera calibration parameters
        var xmpParsedParameters: XmpParsedParameters = XmpParsedParameters()
        // focal length of the lens
        var focalLength: Double?
        // focal plane X resolution
        var focalPlaneXResolution: Double?

        // extract information from EXIF data
        parseExifData(file: file, focalLength: &focalLength, focalPlaneXResolution: &focalPlaneXResolution)

        // extract visible data, thermal data, and calibratrion parameters
        parseParrotData(file: file, visibleData: &visibleData, thermalData: &tiffData, flirData: &flirData,
                        xmpParsedParameters: &xmpParsedParameters)

        // extract thermal data from TIFF
        if let imageData = TiffParser.extractImageData(tiffData: tiffData) {
            thermalData.append(imageData)
        }

        // format version
        var formatVersionMajor: Int32 = 0
        var formatVersionMinor: Int32 = 0
        if let formatVersion = xmpParsedParameters.formatVersion {
            let formatVersionNumbers = formatVersion.split(separator: ".")
            if formatVersionNumbers.count >= 1 {
                formatVersionMajor = Int32(formatVersionNumbers[0]) ?? 0
            }
            if formatVersionNumbers.count >= 2 {
                formatVersionMinor = Int32(formatVersionNumbers[1]) ?? 0
            }
        }

        // use FLIR embedded image for visible image if format version is superior to 0
        if formatVersionMajor > 0 || formatVersionMinor > 0 {
            let visibleDataFromFlir = FlirParser.extractVisibleImageData(flirData: flirData)
            if let visibleDataFromFlir = visibleDataFromFlir {
                visibleData = visibleDataFromFlir
            }
        }

        // decompress the visible image
        var visibleWidth: Int32 = 0
        var visibleHeight: Int32 = 0
        let decompressedVisibleData: Data? = ThermalProcPictureData.decompressJpeg(from: visibleData,
                                                                                   width: &visibleWidth,
                                                                                   height: &visibleHeight)

        // thermal camera model
        var thermalCameraModel = ThermalProcThermalCamera.lepton
        if let droneModelId = xmpParsedParameters.modelId,
            let deviceModel = DeviceModel.from(internalId: droneModelId),
            case .drone(let droneModel) = deviceModel,
            let cameraModel = droneModel.thermalCameraModel {
            thermalCameraModel = cameraModel
        }

        var thermalPicture: ThermalProcPictureData?
        if let decompressedVisibleData = decompressedVisibleData,
            decompressedVisibleData.endIndex > 0,
            thermalData.endIndex > 0 {
            // create the thermal picture
            thermalPicture = ThermalProcPictureData(visibleData: decompressedVisibleData,
                                                visibleWidth: visibleWidth,
                                                visibleHeight: visibleHeight,
                                                thermalData: thermalData,
                                                formatVersionMajor: formatVersionMajor,
                                                formatVersionMinor: formatVersionMinor,
                                                calibR: xmpParsedParameters.calibR,
                                                calibB: xmpParsedParameters.calibB,
                                                calibF: xmpParsedParameters.calibF,
                                                calibO: xmpParsedParameters.calibO,
                                                tauWin: xmpParsedParameters.tauWin,
                                                rWin: xmpParsedParameters.rWin,
                                                sensorTemp: xmpParsedParameters.sensorTemp,
                                                sensorHTemp: xmpParsedParameters.sensorHTemp,
                                                scalingFactor: xmpParsedParameters.scalingFactor,
                                                focalLength: focalLength ?? 0,
                                                focalXResolution: focalPlaneXResolution ?? 0,
                                                viewYaw: xmpParsedParameters.viewYaw ?? 0,
                                                viewPitch: xmpParsedParameters.viewPitch ?? 0,
                                                viewRoll: xmpParsedParameters.viewRoll ?? 0,
                                                visibleCamYaw: xmpParsedParameters.visibleCamYaw ?? 0,
                                                visibleCamPitch: xmpParsedParameters.visibleCamPitch ?? 0,
                                                visibleCamRoll: xmpParsedParameters.visibleCamRoll ?? 0,
                                                thermalCamYaw: xmpParsedParameters.thermalCamYaw ?? 0,
                                                thermalCamPitch: xmpParsedParameters.thermalCamPitch ?? 0,
                                                thermalCamRoll: xmpParsedParameters.thermalCamRoll ?? 0,
                                                cameraModel: thermalCameraModel)
        } else {
            thermalPicture = nil
        }
        return thermalPicture
    }

    /// Extract some camera information from EXIF data.
    ///
    /// - Parameters:
    ///   - file: thermal picture file
    ///   - focalLength: destination of focal length of the len
    ///   - focalPlaneXResolution: destination of focal plane X resolution
    private static func parseExifData(file: URL, focalLength: inout Double?, focalPlaneXResolution: inout Double?) {
        if let imageSource = CGImageSourceCreateWithURL(file as CFURL, nil),
            let imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as Dictionary?,
            let exifDict = imageProperties[kCGImagePropertyExifDictionary] {
            focalLength = exifDict[kCGImagePropertyExifFocalLength] as? Double
            focalPlaneXResolution = exifDict[kCGImagePropertyExifFocalPlaneXResolution] as? Double
        }
    }

    /// Parse Parrot specific data.
    ///
    /// - Parameters:
    ///   - file: thermal picture file
    ///   - visibleData: destination of visible jpeg data
    ///   - thermalData: destination of thermal data
    ///   - xmpParsedParameters: destination of xmp metadata
    private static func parseParrotData(file: URL,
                                        visibleData: inout Data,
                                        thermalData: inout Data,
                                        flirData: inout Data,
                                        xmpParsedParameters: inout XmpParsedParameters) {
        do {
            let data = try Data(contentsOf: file, options: .mappedIfSafe)

            parseSegments(data: data, onVisible: { data in
                visibleData.append(data)
            }, onThermal: { data in
                thermalData.append(data)
            }, onFlir: { data in
                flirData.append(data)
            }, onXmp: { data in
                let parser = XmpParser()
                parser.parse(data: data, parsedParameters: &xmpParsedParameters)
            })
        } catch {
            ULog.w(ThermalPictureParser.TprocTag, "Failed to parse Parrot data")
        }
    }

    /// Parse jpeg segments.
    ///
    /// - Parameters:
    ///   - data: jpeg data
    ///   - onVisible: called when a segment containing visible image data is reached
    ///   - onThermal: called when a segment containing thermal data is reached
    ///   - onXmp: called when a segment containing XMP data is reached
    static func parseSegments(data: Data,
                              onVisible: (Data) -> Void,
                              onThermal: (Data) -> Void,
                              onFlir: (Data) -> Void,
                              onXmp: (Data) -> Void) {
        var position = 0
        while position < data.endIndex {
            let marker1: UInt8 = data[position]
            position += 1
            if marker1 == MARKER_COMMON {
                let marker2: UInt8 = data[position]
                position += 1
                if marker1 == MARKER_COMMON && marker2 != 0 {
                    switch marker2 {
                    case MARKER_SOI, MARKER_EOI, MARKER_RST0, MARKER_RST1, MARKER_RST2, MARKER_RST3, MARKER_RST4,
                        MARKER_RST5, MARKER_RST6, MARKER_RST7:
                        // segment without payload
                        break
                    case MARKER_APP1:
                        // APP1 segment
                        var payloadLen: UInt16 = data[position..<position+2].withUnsafeBytes { $0.pointee }
                        payloadLen = payloadLen.byteSwapped
                        if data[(position+2)..<(position+2+TOKEN_PARROT_VISIBLE.endIndex)] == TOKEN_PARROT_VISIBLE {
                            onVisible(data[(position+10)..<(position+Int(payloadLen))])
                        } else if data[(position+2)..<(position+2+TOKEN_PARROT_THERMAL.endIndex)] == TOKEN_PARROT_THERMAL {
                            onThermal(data[(position+10)..<(position+Int(payloadLen))])
                        } else if data[(position+2)..<(position+2+TOKEN_FLIR.endIndex)] == TOKEN_FLIR {
                            onFlir(data[(position+10)..<(position+Int(payloadLen))])
                        } else if data[(position+2)..<(position+2+TOKEN_XMP.endIndex)] == TOKEN_XMP {
                            onXmp(data[(position+2+TOKEN_XMP.endIndex)..<(position+Int(payloadLen))])
                        }
                        position += Int(payloadLen)
                    default:
                        // other segment with payload
                        var payloadLen: UInt16 = data[position..<position+2].withUnsafeBytes { $0.pointee }
                        payloadLen = payloadLen.byteSwapped
                        position += Int(payloadLen)
                    }
                }
            }
        }
    }

    /// Handle information extracted from XMP parameters.
    private class XmpParsedParameters {
        /// Thermal file format version.
        var formatVersion: String?

        /// Drone model identifier.
        var modelId: Int?

        /// Calibration R parameter.
        var calibR: Double = 0

        /// Calibration B parameter.
        var calibB: Double = 0

        /// Calibration F parameter.
        var calibF: Double = 0

        /// Calibration O parameter.
        var calibO: Double = 0

        /// Transmission coefficient of the thermal window.
        var tauWin: Double = 0

        /// Window reflection.
        var rWin: Double = 0

        /// Sensor temperature reflected, in Kelvin.
        var sensorTemp: Double = 0

        /// Sensor housing temperature, in Kelvin.
        var sensorHTemp: Double = 0

        /// Camera scaling factor.
        var scalingFactor: Double = 0

        /// Yaw orientation of the view in NED (north, east, down coordinates).
        var viewYaw: Double?

        /// Pitch orientation of the view in NED (north, east, down coordinates).
        var viewPitch: Double?

        /// Roll orientation of the view in NED (north, east, down coordinates).
        var viewRoll: Double?

        /// Yaw orientation of the visible camera in NED (north, east, down coordinates).
        var visibleCamYaw: Double?

        /// Pitch orientation of the visible camera in NED (north, east, down coordinates).
        var visibleCamPitch: Double?

        /// Roll orientation of the visible camera in NED (north, east, down coordinates).
        var visibleCamRoll: Double?

        /// Yaw orientation of the thermal camera in NED (north, east, down coordinates).
        var thermalCamYaw: Double?

        /// Pitch orientation of the thermal camera in NED (north, east, down coordinates).
        var thermalCamPitch: Double?

        /// Roll orientation of the thermal camera in NED (north, east, down coordinates).
        var thermalCamRoll: Double?
    }

    /// Parser of XMP metadata.
    ///
    /// Extracts some Parrot specific data usefull for thermal picture display.
    private class XmpParser: NSObject, XMLParserDelegate {

        /// Key for Parrot thermal file format version parameter in XMP metadata.
        private let METADATA_TFILE_VERSION = "drone-parrot:TFileVersion"

        /// Key for calibration's R parameter in XMP metadata.
        private let METADATA_CALIB_R = "drone-parrot:FLIR_CalibR"

        /// Key for calibration's B parameter in XMP metadata.
        private let METADATA_CALIB_B = "drone-parrot:FLIR_CalibB"

        /// Key for calibration's F parameter in XMP metadata.
        private let METADATA_CALIB_F = "drone-parrot:FLIR_CalibF"

        /// Key for calibration's O parameter in XMP metadata.
        private let METADATA_CALIB_O = "drone-parrot:FLIR_CalibO"

        /// Key for transmission coefficient of the window parameter in XMP metadata.
        private let METADATA_TAUWIN = "drone-parrot:FLIR_CalibTauWin"

        /// Key for window reflection parameter in XMP metadata.
        private let METADATA_RWIN = "drone-parrot:Rwin"

        /// Key for sensor temperature parameter in XMP metadata.
        private let METADATA_SENSOR_TEMP = "drone-parrot:TSensor"

        /// Key for sensor housing temperature parameter in XMP metadata.
        private let METADATA_SENSOR_HOUSING_TEMP = "drone-parrot:THousing"

        /// Key for thermal scaling factor parameter in XMP metadata.
        private let METADATA_SCALING_FACTOR = "drone-parrot:FLIR_ScalingFactor"

        /// Key for yaw orientation of view parameter in XMP metadata.
        private let METADATA_VIEW_YAW = "drone-parrot:CameraYawDegree"

        /// Key for pitch orientation of view parameter in XMP metadata.
        private let METADATA_VIEW_PITCH = "drone-parrot:CameraPitchDegree"

        /// Key for roll orientation of view parameter in XMP metadata.
        private let METADATA_VIEW_ROLL = "drone-parrot:CameraRollDegree"

        /// Key for yaw orientation of visible camera parameter in XMP metadata.
        private let METADATA_VISIBLE_CAM_YAW = "drone-parrot:VisibleCameraYawDegree"

        /// Key for pitch orientation of visible camera parameter in XMP metadata.
        private let METADATA_VISIBLE_CAM_PITCH = "drone-parrot:VisibleCameraPitchDegree"

        /// Key for roll orientation of visible camera parameter in XMP metadata.
        private let METADATA_VISIBLE_CAM_ROLL = "drone-parrot:VisibleCameraRollDegree"

        /// Key for yaw orientation of thermal camera parameter in XMP metadata.
        private let METADATA_THERMAL_CAM_YAW = "drone-parrot:ThermalCameraYawDegree"

        /// Key for pitch orientation of thermal camera parameter in XMP metadata.
        private let METADATA_THERMAL_CAM_PITCH = "drone-parrot:ThermalCameraPitchDegree"

        /// Key for roll orientation of thermal camera parameter in XMP metadata.
        private let METADATA_THERMAL_CAM_ROLL = "drone-parrot:ThermalCameraRollDegree"

        /// Key for model id parameter in XMP metadata.
        private let METADATA_MODEL_ID = "drone-parrot:ModelId"

        /// Value parsed for current XML element, as a String.
        var currentValueString: String?

        /// Destination of parsed parameters.
        var parsedParameters: XmpParsedParameters?

        /// Parse XMP metadata.
        ///
        /// - Parameters:
        ///   - data: XMP metadata to parse
        ///   - calibration: destination of parsed calibation data
        func parse(data: Data, parsedParameters: inout XmpParsedParameters) {
            self.parsedParameters = parsedParameters
            let parser = XMLParser(data: data)
            parser.delegate = self
            parser.parse()
        }

        /// See 'XMLParserDelegate' documentation.
        func parser(_ parser: XMLParser,
                    didStartElement elementName: String,
                    namespaceURI: String?,
                    qualifiedName qName: String?,
                    attributes attributeDict: [String: String] = [:]) {
            currentValueString = nil
        }

        /// See 'XMLParserDelegate' documentation.
        func parser(_ parser: XMLParser,
                    didEndElement elementName: String,
                    namespaceURI: String?,
                    qualifiedName qName: String?) {
            guard let value = currentValueString else {
                return
            }
            switch elementName {
            case METADATA_TFILE_VERSION:
                parsedParameters?.formatVersion = currentValueString
            case METADATA_CALIB_R:
                parsedParameters?.calibR = value.asXmpDoubleValue
            case METADATA_CALIB_B:
                parsedParameters?.calibB = value.asXmpDoubleValue
            case METADATA_CALIB_F:
                parsedParameters?.calibF = value.asXmpDoubleValue
            case METADATA_CALIB_O:
                parsedParameters?.calibO = value.asXmpDoubleValue
            case METADATA_TAUWIN:
                parsedParameters?.tauWin = value.asXmpDoubleValue
            case METADATA_RWIN:
                parsedParameters?.rWin = value.asXmpDoubleValue
            case METADATA_SENSOR_TEMP:
                parsedParameters?.sensorTemp = value.asXmpDoubleValue
            case METADATA_SENSOR_HOUSING_TEMP:
                parsedParameters?.sensorHTemp = value.asXmpDoubleValue
            case METADATA_SCALING_FACTOR:
                parsedParameters?.scalingFactor = value.asXmpDoubleValue
            case METADATA_VIEW_YAW:
                parsedParameters?.viewYaw = value.asXmpDoubleValue
            case METADATA_VIEW_PITCH:
                parsedParameters?.viewPitch = value.asXmpDoubleValue
            case METADATA_VIEW_ROLL:
                parsedParameters?.viewRoll = value.asXmpDoubleValue
            case METADATA_VISIBLE_CAM_YAW:
                parsedParameters?.visibleCamYaw = value.asXmpDoubleValue
            case METADATA_VISIBLE_CAM_PITCH:
                parsedParameters?.visibleCamPitch = value.asXmpDoubleValue
            case METADATA_VISIBLE_CAM_ROLL:
                parsedParameters?.visibleCamRoll = value.asXmpDoubleValue
            case METADATA_THERMAL_CAM_YAW:
                parsedParameters?.thermalCamYaw = value.asXmpDoubleValue
            case METADATA_THERMAL_CAM_PITCH:
                parsedParameters?.thermalCamPitch = value.asXmpDoubleValue
            case METADATA_THERMAL_CAM_ROLL:
                parsedParameters?.thermalCamRoll = value.asXmpDoubleValue
            case METADATA_MODEL_ID:
                parsedParameters?.modelId = Int(value, radix: 16) ?? 0
            default:
                break
            }
            currentValueString = nil
        }

        /// See 'XMLParserDelegate' documentation.
        func parser(_ parser: XMLParser, foundCharacters: String) {
            currentValueString = foundCharacters
        }
    }
}

/// TIFF parser.
private class TiffParser {
    /// TIFF header length.
    private static let TIFF_HEADER_LEN = 4
    /// Little endian TIFF header 'I' 'I' 0x2A00.
    private static let TIFF_HEADER_LSB = Data([UInt8(0x49), UInt8(0x49), UInt8(0x2A), UInt8(0x00)])
    /// Big endian TIFF header 'M' 'M' 0x002A.
    private static let TIFF_HEADER_MSB = Data([UInt8(0x4D), UInt8(0x4D), UInt8(0x00), UInt8(0x2A)])

    /// TIFF tag of the byte offset of that strip.
    private static let TIFF_TAG_STRIP_OFFSETS = UInt16(273)
    /// TIFF tag of the number of bytes in the strip.
    private static let TIFF_TAG_STRIP_BYTE_COUNTS = UInt16(279)

    /// Length of the Image File Directories (IFD) offset.
    private static let TIFF_IFD_OFFSET_LEN = 2

    /// Extracts image data from tiff data
    ///
    /// - Parameter tiffData : tiff data to parse
    ///
    /// - Returns: tiff image data
    static func extractImageData(tiffData: Data) -> Data? {
        var imageData = Data()
        let data = ByteBuffer(data: tiffData)

        // Parse endianness
        let endieness = data.readBytes(length: UInt(TiffParser.TIFF_HEADER_LEN))

        if endieness == TiffParser.TIFF_HEADER_LSB {
            data.isLsb = true
        } else if endieness == TiffParser.TIFF_HEADER_MSB {
            data.isLsb = false
        } else {
            ULog.w(ThermalPictureParser.TprocTag, "Tiff endianness parsing error")
            return nil
        }

        // Parse Image File Directories (IFD) address
        var ifdAddr = data.readUInt32()

        // Parse all IDF to look for strip offset and strip length
        while ifdAddr != 0 {
            var stripOffset = 0
            var stripLength = 0
            data.position = UInt(ifdAddr)

            // Parse IFD
            // Parse number of entries in the IFD
            let entriesNumber = data.readUInt16()
            for _ in 0..<entriesNumber {
                // Parse entry TAG
                let tag = data.readUInt16()
                // Parse entry type
                _ = data.readUInt16()
                // Parse entry length
                _ = data.readUInt32()
                // Parse entry offset or values if the data size is less or equal to 4 bytes
                let entryDataOffset = data.readUInt32()

                // Check the tag
                switch tag {
                case TIFF_TAG_STRIP_OFFSETS:
                    stripOffset = Int(entryDataOffset)
                case TIFF_TAG_STRIP_BYTE_COUNTS:
                    stripLength = Int(entryDataOffset)
                default:
                    break
                }
            }
            ifdAddr = data.readUInt32()

            if ifdAddr > data.count {
                ULog.w(ThermalPictureParser.TprocTag, "Tiff IFD offset error")
                return nil
            }

            if stripOffset != 0 && stripLength != 0 {
                // copy the image strip in the destination
                let realStripOffset = tiffData.startIndex + stripOffset
                imageData.append(tiffData[realStripOffset..<realStripOffset + stripLength])
            }
        }

        return imageData
    }
}

/// FLIR data parser.
private class FlirParser {
    /// Size in bytes of header in FLIR embedded image record.
    private static let FLIR_EMBEDDED_IMAGE_HEADER_SIZE: UInt32 = 32

    /// Parsing errors.
    enum FlirParserError: Error {
        /// Not enought remaning data in FLIR data buffer.
        case insufficientData
        /// Trying to access out of FLIR data buffer bounds.
        case outOfBounds
    }

    /// Header of FLIR section.
    class FlirHeader {

        /// Offset in bytes of records headers, from start of FLIR section.
        let recordDirectoryOffset: UInt32

        /// Number of records.
        let nbRecords: UInt32

        /// Creates a FLIR header from FLIR section data.
        ///
        /// - Parameter flirData: `ByteBuffer` where header data are read
        init (flirData: ByteBuffer) throws {
            guard flirData.count >= 64 else {
                throw FlirParserError.insufficientData
            }
            flirData.position = 24
            recordDirectoryOffset = flirData.readUInt32()
            nbRecords = flirData.readUInt32()
            flirData.position += 32
        }
    }

    /// Header of FLIR record.
    class FlirRecordHeader {

        /// Record type value for embedded image.
        static let RECORD_TYPE_EMBEDDED_IMAGE = 0xE

        /// Record type.
        let recordType: UInt16

        /// Record offset in bytes, from start of FLIR section.
        let recordOffest: UInt32

        /// Record length in bytes.
        let recordLength: UInt32

        /// Creates a FLIR record header from FLIR section data.
        ///
        /// - Parameter flirData: `ByteBuffer` where record header data are read
        init (flirData: ByteBuffer) throws {
            guard flirData.count - flirData.position >= 32 else {
                throw FlirParserError.insufficientData
            }
            recordType = flirData.readUInt16()
            flirData.position += 10
            recordOffest = flirData.readUInt32()
            recordLength = flirData.readUInt32()
            flirData.position += 12
        }
    }

    /// Extracts visible image from FLIR section data.
    ///
    /// - Parameter flirData: FLIR section data to parse
    ///
    /// - Returns: visible image extracted from FLIR section data on success, `nil` otherwise
    static func extractVisibleImageData(flirData: Data) -> Data? {
        do {
            let data = ByteBuffer(data: flirData)
            data.isLsb = false
            let header = try FlirHeader(flirData: data)
            data.position = UInt(header.recordDirectoryOffset)
            for _ in 0..<header.nbRecords {
                let recordHeader = try FlirRecordHeader(flirData: data)
                if recordHeader.recordType == FlirRecordHeader.RECORD_TYPE_EMBEDDED_IMAGE {
                    let imageOffset = recordHeader.recordOffest + FLIR_EMBEDDED_IMAGE_HEADER_SIZE
                    let imageLength = recordHeader.recordLength - FLIR_EMBEDDED_IMAGE_HEADER_SIZE
                    if imageOffset < 0 || (imageOffset + imageLength) > flirData.count {
                        throw FlirParserError.outOfBounds
                    }
                    return flirData[imageOffset..<imageOffset + imageLength]
                }
            }
        } catch {
            ULog.w(ThermalPictureParser.TprocTag, "Failed to extract visible image from FLIR data \(error)")
        }
        return nil
    }
}

/// Byte buffer
/// Allow to read through a byte buffer with endianness support.
private class ByteBuffer {
    /// 'true' if the buffer is "Least Significant Bit"; 'false' if the buffer is "Most Significant Bit".
    var isLsb = true
    /// Buffer's position in bytes from data.startIndex
    var position = UInt(0)
    /// The number of bytes in the buffer.
    var count: UInt {
        return UInt(data.count)
    }
    /// Data to read.
    private let data: Data
    /// Buffer position in bytes from data[0].
    private var dataPosition: Int {
        return data.startIndex + Int(position)
    }

    /// Constructor.
    ///
    /// - Parameter data : data to read
    init (data: Data) {
        self.data = data
    }

    /// Reads bytes and moves forward the offset after the data read.
    ///
    /// - Parameter length : number of bytes to read
    ///
    /// - Returns: read bytes
    func readBytes(length: UInt) -> Data {
        let value = data[dataPosition..<dataPosition+Int(length)]
        position += length
        return value
    }

    /// Reads the next two bytes at this buffer's current position,
    /// composing them into a UInt16 value according to the current byte order,
    /// and then increments the position by two.
    ///
    /// - Returns: The UInt16 value at the buffer's current position
    func readUInt16() -> UInt16 {
        let value: UInt16 = data[dataPosition..<dataPosition+2].withUnsafeBytes { $0.pointee }
        position += 2
        return isLsb ? value.littleEndian : value.bigEndian
    }

    /// Reads the next four bytes at this buffer's current position,
    /// composing them into a UInt32 value according to the current byte order,
    /// and then increments the position by four.
    ///
    /// - Returns: The UInt32 value at the buffer's current position
    func readUInt32() -> UInt32 {
        let value: UInt32 = data[dataPosition..<dataPosition+4].withUnsafeBytes { $0.pointee }
        position += 4
        return isLsb ? value.littleEndian : value.bigEndian
    }
}

/// Extension to parse String as XMP parameter value.
extension String {
    /// Parse String as a Double XMP parameter value.
    /// `0` if failed to parse value.
    var asXmpDoubleValue: Double {
        var value = 0.0
        let operands = split(separator: "/")
        if operands.count == 1 {
            value = Double(self) ?? 0
        } else if operands.count == 2,
            let numerator = Double(operands[0]),
            let denominator = Double(operands[1]) {
                value = numerator / denominator
        }
        return value
    }
}

extension Drone.Model {
    /// Thermal camera model of that drone model.
    var thermalCameraModel: ThermalProcThermalCamera? {
        switch self {
        case .anafiThermal:
            return .lepton
        case .anafiUa, .anafiUsa:
            return .boson
        default:
            return nil
        }
    }
}
