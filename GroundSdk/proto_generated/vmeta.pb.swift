// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vmeta.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//*
// Copyright (c) 2016 Parrot Drones SAS
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//   * Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//   * Neither the name of the Parrot Drones SAS Company nor the
//     names of its contributors may be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE PARROT DRONES SAS COMPANY BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Vmeta_TrackingClass: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Person 
  case tcPerson // = 0

  /// Animal 
  case tcAnimal // = 1

  /// Bicycle 
  case tcBicycle // = 2

  /// Boat 
  case tcBoat // = 3

  /// Car 
  case tcCar // = 4

  /// Horse 
  case tcHorse // = 5

  /// Motorbike 
  case tcMotorbike // = 6

  /// Undefined (object not recognized).
  /// Value is kept at the highest 1byte varint for clarity,
  /// and to reserve space for future values 
  case tcUndefined // = 127
  case UNRECOGNIZED(Int)

  public init() {
    self = .tcPerson
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tcPerson
    case 1: self = .tcAnimal
    case 2: self = .tcBicycle
    case 3: self = .tcBoat
    case 4: self = .tcCar
    case 5: self = .tcHorse
    case 6: self = .tcMotorbike
    case 127: self = .tcUndefined
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tcPerson: return 0
    case .tcAnimal: return 1
    case .tcBicycle: return 2
    case .tcBoat: return 3
    case .tcCar: return 4
    case .tcHorse: return 5
    case .tcMotorbike: return 6
    case .tcUndefined: return 127
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Vmeta_TrackingClass: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Vmeta_TrackingClass] = [
    .tcPerson,
    .tcAnimal,
    .tcBicycle,
    .tcBoat,
    .tcCar,
    .tcHorse,
    .tcMotorbike,
    .tcUndefined,
  ]
}

#endif  // swift(>=4.2)

public enum Vmeta_TrackingState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Tracking 
  case tsTracking // = 0

  /// Searching 
  case tsSearching // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .tsTracking
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tsTracking
    case 1: self = .tsSearching
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tsTracking: return 0
    case .tsSearching: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Vmeta_TrackingState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Vmeta_TrackingState] = [
    .tsTracking,
    .tsSearching,
  ]
}

#endif  // swift(>=4.2)

public enum Vmeta_FlyingState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Landed state 
  case fsLanded // = 0

  /// Taking off state 
  case fsTakingoff // = 1

  /// Hovering state 
  case fsHovering // = 2

  /// Flying state 
  case fsFlying // = 3

  /// Landing state 
  case fsLanding // = 4

  /// Emergency state 
  case fsEmergency // = 5

  /// User-takeoff state 
  case fsUserTakeoff // = 6

  /// Motor-ramping state 
  case fsMotorRamping // = 7

  /// Emergency-landing state 
  case fsEmergencyLanding // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .fsLanded
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fsLanded
    case 1: self = .fsTakingoff
    case 2: self = .fsHovering
    case 3: self = .fsFlying
    case 4: self = .fsLanding
    case 5: self = .fsEmergency
    case 6: self = .fsUserTakeoff
    case 7: self = .fsMotorRamping
    case 8: self = .fsEmergencyLanding
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .fsLanded: return 0
    case .fsTakingoff: return 1
    case .fsHovering: return 2
    case .fsFlying: return 3
    case .fsLanding: return 4
    case .fsEmergency: return 5
    case .fsUserTakeoff: return 6
    case .fsMotorRamping: return 7
    case .fsEmergencyLanding: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Vmeta_FlyingState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Vmeta_FlyingState] = [
    .fsLanded,
    .fsTakingoff,
    .fsHovering,
    .fsFlying,
    .fsLanding,
    .fsEmergency,
    .fsUserTakeoff,
    .fsMotorRamping,
    .fsEmergencyLanding,
  ]
}

#endif  // swift(>=4.2)

public enum Vmeta_PilotingMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown/not available 
  case pmUnknown // = 0

  /// Manual piloting 
  case pmManual // = 1

  /// Automatic return home 
  case pmReturnHome // = 2

  /// Automatic flight plan 
  case pmFlightPlan // = 3

  /// Automatic tracking 
  case pmTracking // = 4

  /// Automatic move-to 
  case pmMoveto // = 5

  /// Automatic "magic-carpet" test 
  case pmMagicCarpet // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .pmUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pmUnknown
    case 1: self = .pmManual
    case 2: self = .pmReturnHome
    case 3: self = .pmFlightPlan
    case 4: self = .pmTracking
    case 5: self = .pmMoveto
    case 6: self = .pmMagicCarpet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .pmUnknown: return 0
    case .pmManual: return 1
    case .pmReturnHome: return 2
    case .pmFlightPlan: return 3
    case .pmTracking: return 4
    case .pmMoveto: return 5
    case .pmMagicCarpet: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Vmeta_PilotingMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Vmeta_PilotingMode] = [
    .pmUnknown,
    .pmManual,
    .pmReturnHome,
    .pmFlightPlan,
    .pmTracking,
    .pmMoveto,
    .pmMagicCarpet,
  ]
}

#endif  // swift(>=4.2)

public enum Vmeta_Animation: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// None 
  case animNone // = 0

  /// Orbit 
  case animOrbit // = 1

  /// Boomerang 
  case animBoomerang // = 2

  /// Parabola 
  case animParabola // = 3

  /// Dolly slide 
  case animDollySlide // = 4

  /// Dolly zoom 
  case animDollyZoom // = 5

  /// Vertical reveal 
  case animRevealVert // = 6

  /// Horizontal reveal 
  case animRevealHoriz // = 7

  /// Horizontal panorama 
  case animPanoHoriz // = 8

  /// Candle 
  case animCandle // = 9

  /// Front flip 
  case animFlipFront // = 10

  /// Back flip 
  case animFlipBack // = 11

  /// Left flip 
  case animFlipLeft // = 12

  /// Right flip 
  case animFlipRight // = 13

  /// Twist-up 
  case animTwistup // = 14

  /// Position twist-up 
  case animPositionTwistup // = 15
  case UNRECOGNIZED(Int)

  public init() {
    self = .animNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .animNone
    case 1: self = .animOrbit
    case 2: self = .animBoomerang
    case 3: self = .animParabola
    case 4: self = .animDollySlide
    case 5: self = .animDollyZoom
    case 6: self = .animRevealVert
    case 7: self = .animRevealHoriz
    case 8: self = .animPanoHoriz
    case 9: self = .animCandle
    case 10: self = .animFlipFront
    case 11: self = .animFlipBack
    case 12: self = .animFlipLeft
    case 13: self = .animFlipRight
    case 14: self = .animTwistup
    case 15: self = .animPositionTwistup
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .animNone: return 0
    case .animOrbit: return 1
    case .animBoomerang: return 2
    case .animParabola: return 3
    case .animDollySlide: return 4
    case .animDollyZoom: return 5
    case .animRevealVert: return 6
    case .animRevealHoriz: return 7
    case .animPanoHoriz: return 8
    case .animCandle: return 9
    case .animFlipFront: return 10
    case .animFlipBack: return 11
    case .animFlipLeft: return 12
    case .animFlipRight: return 13
    case .animTwistup: return 14
    case .animPositionTwistup: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Vmeta_Animation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Vmeta_Animation] = [
    .animNone,
    .animOrbit,
    .animBoomerang,
    .animParabola,
    .animDollySlide,
    .animDollyZoom,
    .animRevealVert,
    .animRevealHoriz,
    .animPanoHoriz,
    .animCandle,
    .animFlipFront,
    .animFlipBack,
    .animFlipLeft,
    .animFlipRight,
    .animTwistup,
    .animPositionTwistup,
  ]
}

#endif  // swift(>=4.2)

public enum Vmeta_LinkType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown 
  case unknown // = 0

  /// Reserved 
  case lo // = 1

  /// Reserved 
  case lan // = 2

  /// Wlan (Wi-Fi) interface 
  case wlan // = 3

  /// Cellular (4G) interface 
  case cellular // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .lo
    case 2: self = .lan
    case 3: self = .wlan
    case 4: self = .cellular
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .lo: return 1
    case .lan: return 2
    case .wlan: return 3
    case .cellular: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Vmeta_LinkType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Vmeta_LinkType] = [
    .unknown,
    .lo,
    .lan,
    .wlan,
    .cellular,
  ]
}

#endif  // swift(>=4.2)

public enum Vmeta_LinkStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Interface is down 
  case down // = 0

  /// Interface is up with IP connectivity 
  case up // = 1

  /// Starfish session established on the link 
  case running // = 2

  /// Link is ready to connect or accept connections 
  case ready // = 3

  /// Connection in progress 
  case connecting // = 4

  /// Link error 
  case error // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .down
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .down
    case 1: self = .up
    case 2: self = .running
    case 3: self = .ready
    case 4: self = .connecting
    case 5: self = .error
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .down: return 0
    case .up: return 1
    case .running: return 2
    case .ready: return 3
    case .connecting: return 4
    case .error: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Vmeta_LinkStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Vmeta_LinkStatus] = [
    .down,
    .up,
    .running,
    .ready,
    .connecting,
    .error,
  ]
}

#endif  // swift(>=4.2)

public enum Vmeta_ThermalCalibrationState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// OK/Done 
  case tcsDone // = 0

  /// Requested 
  case tcsRequested // = 1

  /// In progress 
  case tcsInProgress // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .tcsDone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tcsDone
    case 1: self = .tcsRequested
    case 2: self = .tcsInProgress
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tcsDone: return 0
    case .tcsRequested: return 1
    case .tcsInProgress: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Vmeta_ThermalCalibrationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Vmeta_ThermalCalibrationState] = [
    .tcsDone,
    .tcsRequested,
    .tcsInProgress,
  ]
}

#endif  // swift(>=4.2)

/// Unit quaternion 
public struct Vmeta_Quaternion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var w: Float = 0

  public var x: Float = 0

  public var y: Float = 0

  public var z: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Location on earth 
public struct Vmeta_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Latitude and longitude (degrees) 
  public var latitude: Double = 0

  public var longitude: Double = 0

  /// Altitude above the WGS84 ellipsoid (m) (zero means unknown) 
  public var altitudeWgs84Ellipsoid: Double = 0

  /// Altitude above the EGM96 geoid (AMSL) (m) (zero means unknown) 
  public var altitudeEgm96Amsl: Double = 0

  /// Horizontal and vertical location accuracy (m), zero means unknown 
  public var horizontalAccuracy: Float = 0

  public var verticalAccuracy: Float = 0

  /// GPS Satellite vehicle count, only set if location comes at least
  /// partially from a GPS sensor 
  public var svCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Generic 2 component vector 
public struct Vmeta_Vector2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Float = 0

  public var y: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Generic 3 component vector 
public struct Vmeta_Vector3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Float = 0

  public var y: Float = 0

  public var z: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 3 component vector, in NED frame 
public struct Vmeta_NED {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var north: Float = 0

  public var east: Float = 0

  public var down: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Bounding box for tracking and proposal 
public struct Vmeta_BoundingBox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Position [0; 1] in picture 
  public var x: Float = 0

  public var y: Float = 0

  /// Dimensions [0; 1] relative to picture 
  public var width: Float = 0

  public var height: Float = 0

  /// Type of tracked object 
  public var objectClass: Vmeta_TrackingClass = .tcPerson

  /// Tracking confidence [0; 1] 
  public var confidence: Float = 0

  /// Box unique identifier (UID). Multiple BoundingBox messages sharing
  /// the same UID refers to the same bounding box 
  public var uid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Thermal spot for thermal metadata 
public struct Vmeta_ThermalSpot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Position [0; 1] in picture 
  public var x: Float = 0

  public var y: Float = 0

  /// Temperature, in either Kelvin for radiometric sensors,
  /// or raw sensor unit for non-radiometric sensors 
  public var temp: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vmeta_DroneMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Drone quaternion 
  public var quat: Vmeta_Quaternion {
    get {return _storage._quat ?? Vmeta_Quaternion()}
    set {_uniqueStorage()._quat = newValue}
  }
  /// Returns true if `quat` has been explicitly set.
  public var hasQuat: Bool {return _storage._quat != nil}
  /// Clears the value of `quat`. Subsequent reads from it will return its default value.
  public mutating func clearQuat() {_uniqueStorage()._quat = nil}

  /// Drone location 
  public var location: Vmeta_Location {
    get {return _storage._location ?? Vmeta_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {_uniqueStorage()._location = nil}

  /// Best ground distance estimation (m) 
  public var groundDistance: Double {
    get {return _storage._groundDistance}
    set {_uniqueStorage()._groundDistance = newValue}
  }

  /// Estimated position of the drone in NED frame (m).
  /// The position is initialized at first take off. When this position may
  /// have drifted from the true position (for example when GPS signal is
  /// not available), this position jumps on the first absolute position
  /// measurement available. 
  public var position: Vmeta_NED {
    get {return _storage._position ?? Vmeta_NED()}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return _storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {_uniqueStorage()._position = nil}

  /// Estimated position of the drone in the local frame (m).
  /// The local frame is not NED: X and Y axis are arbitrary, but the Z
  /// axis is guaranteed to point down.
  /// The position is initialized at first take off. This position is
  /// guaranteed not to jump, even when a new absolute position (usually
  /// GPS) is available. Instead, the origin of the local frame jumps in
  /// order to ensure the continuity of the local position.
  public var localPosition: Vmeta_Vector3 {
    get {return _storage._localPosition ?? Vmeta_Vector3()}
    set {_uniqueStorage()._localPosition = newValue}
  }
  /// Returns true if `localPosition` has been explicitly set.
  public var hasLocalPosition: Bool {return _storage._localPosition != nil}
  /// Clears the value of `localPosition`. Subsequent reads from it will return its default value.
  public mutating func clearLocalPosition() {_uniqueStorage()._localPosition = nil}

  /// Speed vector in NED (North-East-Down) (m/s) 
  public var speed: Vmeta_NED {
    get {return _storage._speed ?? Vmeta_NED()}
    set {_uniqueStorage()._speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  public var hasSpeed: Bool {return _storage._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  public mutating func clearSpeed() {_uniqueStorage()._speed = nil}

  /// Battery charge percentage 
  public var batteryPercentage: Int32 {
    get {return _storage._batteryPercentage}
    set {_uniqueStorage()._batteryPercentage = newValue}
  }

  /// Flying state 
  public var flyingState: Vmeta_FlyingState {
    get {return _storage._flyingState}
    set {_uniqueStorage()._flyingState = newValue}
  }

  /// Animation in progreess 
  public var animationInProgress: Bool {
    get {return _storage._animationInProgress}
    set {_uniqueStorage()._animationInProgress = newValue}
  }

  /// Piloting mode 
  public var pilotingMode: Vmeta_PilotingMode {
    get {return _storage._pilotingMode}
    set {_uniqueStorage()._pilotingMode = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Vmeta_CameraMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Frame capture timestamp (us, monotonic) 
  public var timestamp: UInt64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  /// Frame capture UTC timestamp (us since the Epoch) 
  public var utcTimestamp: UInt64 {
    get {return _storage._utcTimestamp}
    set {_uniqueStorage()._utcTimestamp = newValue}
  }

  /// Frame capture UTC timestamp accuracy (us); zero means unknown,
  /// utc_timestamp must then be considered invalid 
  public var utcTimestampAccuracy: UInt32 {
    get {return _storage._utcTimestampAccuracy}
    set {_uniqueStorage()._utcTimestampAccuracy = newValue}
  }

  /// Frame base view quaternion (without user pan/tilt) 
  public var baseQuat: Vmeta_Quaternion {
    get {return _storage._baseQuat ?? Vmeta_Quaternion()}
    set {_uniqueStorage()._baseQuat = newValue}
  }
  /// Returns true if `baseQuat` has been explicitly set.
  public var hasBaseQuat: Bool {return _storage._baseQuat != nil}
  /// Clears the value of `baseQuat`. Subsequent reads from it will return its default value.
  public mutating func clearBaseQuat() {_uniqueStorage()._baseQuat = nil}

  /// Frame view quaternion 
  public var quat: Vmeta_Quaternion {
    get {return _storage._quat ?? Vmeta_Quaternion()}
    set {_uniqueStorage()._quat = newValue}
  }
  /// Returns true if `quat` has been explicitly set.
  public var hasQuat: Bool {return _storage._quat != nil}
  /// Clears the value of `quat`. Subsequent reads from it will return its default value.
  public mutating func clearQuat() {_uniqueStorage()._quat = nil}

  /// Estimated position of the camera in the local frame (m).
  /// The local frame is not NED: X and Y axis are arbitrary, but the Z
  /// axis is guaranteed to point down.
  /// The position is initialized at first take off. This position is
  /// guaranteed not to jump, even when a new absolute position (usually
  /// GPS) is available. Instead, the origin of the local frame jumps in
  /// order to ensure the continuity of the local position.
  /// This position is not available on all cameras. If not available,
  /// the Drone.local_position metadata should be used instead.
  public var localPosition: Vmeta_Vector3 {
    get {return _storage._localPosition ?? Vmeta_Vector3()}
    set {_uniqueStorage()._localPosition = newValue}
  }
  /// Returns true if `localPosition` has been explicitly set.
  public var hasLocalPosition: Bool {return _storage._localPosition != nil}
  /// Clears the value of `localPosition`. Subsequent reads from it will return its default value.
  public mutating func clearLocalPosition() {_uniqueStorage()._localPosition = nil}

  /// Camera location 
  public var location: Vmeta_Location {
    get {return _storage._location ?? Vmeta_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {_uniqueStorage()._location = nil}

  /// Camera principal point normalized coordinates in picture [0; 1] 
  public var principalPoint: Vmeta_Vector2 {
    get {return _storage._principalPoint ?? Vmeta_Vector2()}
    set {_uniqueStorage()._principalPoint = newValue}
  }
  /// Returns true if `principalPoint` has been explicitly set.
  public var hasPrincipalPoint: Bool {return _storage._principalPoint != nil}
  /// Clears the value of `principalPoint`. Subsequent reads from it will return its default value.
  public mutating func clearPrincipalPoint() {_uniqueStorage()._principalPoint = nil}

  /// Frame exposure time (ms) 
  public var exposureTime: Float {
    get {return _storage._exposureTime}
    set {_uniqueStorage()._exposureTime = newValue}
  }

  /// Frame ISO gain 
  public var isoGain: UInt32 {
    get {return _storage._isoGain}
    set {_uniqueStorage()._isoGain = newValue}
  }

  /// Frame AWB red gain 
  public var awbRGain: Float {
    get {return _storage._awbRGain}
    set {_uniqueStorage()._awbRGain = newValue}
  }

  /// Frame AWB blue gain 
  public var awbBGain: Float {
    get {return _storage._awbBGain}
    set {_uniqueStorage()._awbBGain = newValue}
  }

  /// Frame horizontal field of view (rad) 
  public var hfov: Float {
    get {return _storage._hfov}
    set {_uniqueStorage()._hfov = newValue}
  }

  /// Frame vertical field of view (rad) 
  public var vfov: Float {
    get {return _storage._vfov}
    set {_uniqueStorage()._vfov = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Vmeta_TrackingProposalMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of proposed bounding boxes 
  public var proposals: [Vmeta_BoundingBox] = []

  /// Processed frame capture timestamp (us, monotonic)
  /// note: may be different from the timestamp in CameraMetadata 
  public var timestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vmeta_TrackingMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tracking target 
  public var target: Vmeta_BoundingBox {
    get {return _target ?? Vmeta_BoundingBox()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  public var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  public mutating func clearTarget() {self._target = nil}

  /// Processed frame capture timestamp (us, monotonic)
  /// note: may be different from the timestamp in CameraMetadata 
  public var timestamp: UInt64 = 0

  /// Tracking quality ([0; 255], 0 is worst, 255 is best) 
  public var quality: UInt32 = 0

  /// Tracking state 
  public var state: Vmeta_TrackingState = .tsTracking

  /// Cookie value passed by the app when the tracking is started 
  public var cookie: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _target: Vmeta_BoundingBox? = nil
}

public struct Vmeta_AutomationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current destination 
  public var destination: Vmeta_Location {
    get {return _storage._destination ?? Vmeta_Location()}
    set {_uniqueStorage()._destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return _storage._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {_uniqueStorage()._destination = nil}

  /// Tracking target location 
  public var targetLocation: Vmeta_Location {
    get {return _storage._targetLocation ?? Vmeta_Location()}
    set {_uniqueStorage()._targetLocation = newValue}
  }
  /// Returns true if `targetLocation` has been explicitly set.
  public var hasTargetLocation: Bool {return _storage._targetLocation != nil}
  /// Clears the value of `targetLocation`. Subsequent reads from it will return its default value.
  public mutating func clearTargetLocation() {_uniqueStorage()._targetLocation = nil}

  /// Follow-me enabled 
  public var followMe: Bool {
    get {return _storage._followMe}
    set {_uniqueStorage()._followMe = newValue}
  }

  /// Look-at-me enabled 
  public var lookatMe: Bool {
    get {return _storage._lookatMe}
    set {_uniqueStorage()._lookatMe = newValue}
  }

  /// Angle-locked:
  /// false: NED (North-East-Down) absolute angle mode
  /// true: constant angle relative to the target movement 
  public var angleLocked: Bool {
    get {return _storage._angleLocked}
    set {_uniqueStorage()._angleLocked = newValue}
  }

  /// Current animation 
  public var animation: Vmeta_Animation {
    get {return _storage._animation}
    set {_uniqueStorage()._animation = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Vmeta_WifiLinkMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Wifi link goodput (throughput estimation) (kbit/s) 
  public var goodput: UInt32 = 0

  /// Wifi link quality ([0; 5], 0 is worst, 5 is best) 
  public var quality: UInt32 = 0

  /// Wifi link RSSI (dBm) 
  public var rssi: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vmeta_StarfishLinkInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of link 
  public var type: Vmeta_LinkType = .unknown

  /// Link status 
  public var status: Vmeta_LinkStatus = .down

  /// Link quality indication: 1 (lower) to 5 (better),
  /// 0 if not available 
  public var quality: Int32 = 0

  /// Link active status 
  public var active: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vmeta_StarfishLinkMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Links 
  public var links: [Vmeta_StarfishLinkInfo] = []

  /// Global link quality indication: 1 (lower) to 5 (better),
  /// 0 if not available 
  public var quality: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vmeta_LinkMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var `protocol`: Vmeta_LinkMetadata.OneOf_Protocol? = nil

  /// Wifi link metadata 
  public var wifi: Vmeta_WifiLinkMetadata {
    get {
      if case .wifi(let v)? = `protocol` {return v}
      return Vmeta_WifiLinkMetadata()
    }
    set {`protocol` = .wifi(newValue)}
  }

  /// Starfish link metadata 
  public var starfish: Vmeta_StarfishLinkMetadata {
    get {
      if case .starfish(let v)? = `protocol` {return v}
      return Vmeta_StarfishLinkMetadata()
    }
    set {`protocol` = .starfish(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Protocol: Equatable {
    /// Wifi link metadata 
    case wifi(Vmeta_WifiLinkMetadata)
    /// Starfish link metadata 
    case starfish(Vmeta_StarfishLinkMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Vmeta_LinkMetadata.OneOf_Protocol, rhs: Vmeta_LinkMetadata.OneOf_Protocol) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.wifi, .wifi): return {
        guard case .wifi(let l) = lhs, case .wifi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.starfish, .starfish): return {
        guard case .starfish(let l) = lhs, case .starfish(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Vmeta_ThermalMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Thermal calibration state 
  public var calibrationState: Vmeta_ThermalCalibrationState = .tcsDone

  /// Minimum temperature spot 
  public var min: Vmeta_ThermalSpot {
    get {return _min ?? Vmeta_ThermalSpot()}
    set {_min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  public var hasMin: Bool {return self._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  public mutating func clearMin() {self._min = nil}

  /// Maximum temperature spot 
  public var max: Vmeta_ThermalSpot {
    get {return _max ?? Vmeta_ThermalSpot()}
    set {_max = newValue}
  }
  /// Returns true if `max` has been explicitly set.
  public var hasMax: Bool {return self._max != nil}
  /// Clears the value of `max`. Subsequent reads from it will return its default value.
  public mutating func clearMax() {self._max = nil}

  /// Probe temperature spot 
  public var probe: Vmeta_ThermalSpot {
    get {return _probe ?? Vmeta_ThermalSpot()}
    set {_probe = newValue}
  }
  /// Returns true if `probe` has been explicitly set.
  public var hasProbe: Bool {return self._probe != nil}
  /// Clears the value of `probe`. Subsequent reads from it will return its default value.
  public mutating func clearProbe() {self._probe = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _min: Vmeta_ThermalSpot? = nil
  fileprivate var _max: Vmeta_ThermalSpot? = nil
  fileprivate var _probe: Vmeta_ThermalSpot? = nil
}

public struct Vmeta_LFICMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Position of target [0; 1] in picture 
  public var x: Float = 0

  public var y: Float = 0

  /// Location of target 
  public var location: Vmeta_Location {
    get {return _location ?? Vmeta_Location()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  /// Grid precision used for calculation (m) 
  public var gridPrecision: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _location: Vmeta_Location? = nil
}

public struct Vmeta_TimedMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Drone-related metadata 
  public var drone: Vmeta_DroneMetadata {
    get {return _storage._drone ?? Vmeta_DroneMetadata()}
    set {_uniqueStorage()._drone = newValue}
  }
  /// Returns true if `drone` has been explicitly set.
  public var hasDrone: Bool {return _storage._drone != nil}
  /// Clears the value of `drone`. Subsequent reads from it will return its default value.
  public mutating func clearDrone() {_uniqueStorage()._drone = nil}

  /// Camera-related metadata 
  public var camera: Vmeta_CameraMetadata {
    get {return _storage._camera ?? Vmeta_CameraMetadata()}
    set {_uniqueStorage()._camera = newValue}
  }
  /// Returns true if `camera` has been explicitly set.
  public var hasCamera: Bool {return _storage._camera != nil}
  /// Clears the value of `camera`. Subsequent reads from it will return its default value.
  public mutating func clearCamera() {_uniqueStorage()._camera = nil}

  /// Link-related metadata, one per available link 
  public var links: [Vmeta_LinkMetadata] {
    get {return _storage._links}
    set {_uniqueStorage()._links = newValue}
  }

  /// Tracking metadata 
  public var tracking: Vmeta_TrackingMetadata {
    get {return _storage._tracking ?? Vmeta_TrackingMetadata()}
    set {_uniqueStorage()._tracking = newValue}
  }
  /// Returns true if `tracking` has been explicitly set.
  public var hasTracking: Bool {return _storage._tracking != nil}
  /// Clears the value of `tracking`. Subsequent reads from it will return its default value.
  public mutating func clearTracking() {_uniqueStorage()._tracking = nil}

  /// Tracking proposal metadata 
  public var proposal: Vmeta_TrackingProposalMetadata {
    get {return _storage._proposal ?? Vmeta_TrackingProposalMetadata()}
    set {_uniqueStorage()._proposal = newValue}
  }
  /// Returns true if `proposal` has been explicitly set.
  public var hasProposal: Bool {return _storage._proposal != nil}
  /// Clears the value of `proposal`. Subsequent reads from it will return its default value.
  public mutating func clearProposal() {_uniqueStorage()._proposal = nil}

  /// Automation metadata 
  public var automation: Vmeta_AutomationMetadata {
    get {return _storage._automation ?? Vmeta_AutomationMetadata()}
    set {_uniqueStorage()._automation = newValue}
  }
  /// Returns true if `automation` has been explicitly set.
  public var hasAutomation: Bool {return _storage._automation != nil}
  /// Clears the value of `automation`. Subsequent reads from it will return its default value.
  public mutating func clearAutomation() {_uniqueStorage()._automation = nil}

  /// Thermal metadata 
  public var thermal: Vmeta_ThermalMetadata {
    get {return _storage._thermal ?? Vmeta_ThermalMetadata()}
    set {_uniqueStorage()._thermal = newValue}
  }
  /// Returns true if `thermal` has been explicitly set.
  public var hasThermal: Bool {return _storage._thermal != nil}
  /// Clears the value of `thermal`. Subsequent reads from it will return its default value.
  public mutating func clearThermal() {_uniqueStorage()._thermal = nil}

  /// Location From Image Coordinates (LFIC) metadata 
  public var lfic: Vmeta_LFICMetadata {
    get {return _storage._lfic ?? Vmeta_LFICMetadata()}
    set {_uniqueStorage()._lfic = newValue}
  }
  /// Returns true if `lfic` has been explicitly set.
  public var hasLfic: Bool {return _storage._lfic != nil}
  /// Clears the value of `lfic`. Subsequent reads from it will return its default value.
  public mutating func clearLfic() {_uniqueStorage()._lfic = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Vmeta_TrackingClass: @unchecked Sendable {}
extension Vmeta_TrackingState: @unchecked Sendable {}
extension Vmeta_FlyingState: @unchecked Sendable {}
extension Vmeta_PilotingMode: @unchecked Sendable {}
extension Vmeta_Animation: @unchecked Sendable {}
extension Vmeta_LinkType: @unchecked Sendable {}
extension Vmeta_LinkStatus: @unchecked Sendable {}
extension Vmeta_ThermalCalibrationState: @unchecked Sendable {}
extension Vmeta_Quaternion: @unchecked Sendable {}
extension Vmeta_Location: @unchecked Sendable {}
extension Vmeta_Vector2: @unchecked Sendable {}
extension Vmeta_Vector3: @unchecked Sendable {}
extension Vmeta_NED: @unchecked Sendable {}
extension Vmeta_BoundingBox: @unchecked Sendable {}
extension Vmeta_ThermalSpot: @unchecked Sendable {}
extension Vmeta_DroneMetadata: @unchecked Sendable {}
extension Vmeta_CameraMetadata: @unchecked Sendable {}
extension Vmeta_TrackingProposalMetadata: @unchecked Sendable {}
extension Vmeta_TrackingMetadata: @unchecked Sendable {}
extension Vmeta_AutomationMetadata: @unchecked Sendable {}
extension Vmeta_WifiLinkMetadata: @unchecked Sendable {}
extension Vmeta_StarfishLinkInfo: @unchecked Sendable {}
extension Vmeta_StarfishLinkMetadata: @unchecked Sendable {}
extension Vmeta_LinkMetadata: @unchecked Sendable {}
extension Vmeta_LinkMetadata.OneOf_Protocol: @unchecked Sendable {}
extension Vmeta_ThermalMetadata: @unchecked Sendable {}
extension Vmeta_LFICMetadata: @unchecked Sendable {}
extension Vmeta_TimedMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "vmeta"

extension Vmeta_TrackingClass: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TC_PERSON"),
    1: .same(proto: "TC_ANIMAL"),
    2: .same(proto: "TC_BICYCLE"),
    3: .same(proto: "TC_BOAT"),
    4: .same(proto: "TC_CAR"),
    5: .same(proto: "TC_HORSE"),
    6: .same(proto: "TC_MOTORBIKE"),
    127: .same(proto: "TC_UNDEFINED"),
  ]
}

extension Vmeta_TrackingState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TS_TRACKING"),
    1: .same(proto: "TS_SEARCHING"),
  ]
}

extension Vmeta_FlyingState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FS_LANDED"),
    1: .same(proto: "FS_TAKINGOFF"),
    2: .same(proto: "FS_HOVERING"),
    3: .same(proto: "FS_FLYING"),
    4: .same(proto: "FS_LANDING"),
    5: .same(proto: "FS_EMERGENCY"),
    6: .same(proto: "FS_USER_TAKEOFF"),
    7: .same(proto: "FS_MOTOR_RAMPING"),
    8: .same(proto: "FS_EMERGENCY_LANDING"),
  ]
}

extension Vmeta_PilotingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PM_UNKNOWN"),
    1: .same(proto: "PM_MANUAL"),
    2: .same(proto: "PM_RETURN_HOME"),
    3: .same(proto: "PM_FLIGHT_PLAN"),
    4: .same(proto: "PM_TRACKING"),
    5: .same(proto: "PM_MOVETO"),
    6: .same(proto: "PM_MAGIC_CARPET"),
  ]
}

extension Vmeta_Animation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANIM_NONE"),
    1: .same(proto: "ANIM_ORBIT"),
    2: .same(proto: "ANIM_BOOMERANG"),
    3: .same(proto: "ANIM_PARABOLA"),
    4: .same(proto: "ANIM_DOLLY_SLIDE"),
    5: .same(proto: "ANIM_DOLLY_ZOOM"),
    6: .same(proto: "ANIM_REVEAL_VERT"),
    7: .same(proto: "ANIM_REVEAL_HORIZ"),
    8: .same(proto: "ANIM_PANO_HORIZ"),
    9: .same(proto: "ANIM_CANDLE"),
    10: .same(proto: "ANIM_FLIP_FRONT"),
    11: .same(proto: "ANIM_FLIP_BACK"),
    12: .same(proto: "ANIM_FLIP_LEFT"),
    13: .same(proto: "ANIM_FLIP_RIGHT"),
    14: .same(proto: "ANIM_TWISTUP"),
    15: .same(proto: "ANIM_POSITION_TWISTUP"),
  ]
}

extension Vmeta_LinkType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LINK_TYPE_UNKNOWN"),
    1: .same(proto: "LINK_TYPE_LO"),
    2: .same(proto: "LINK_TYPE_LAN"),
    3: .same(proto: "LINK_TYPE_WLAN"),
    4: .same(proto: "LINK_TYPE_CELLULAR"),
  ]
}

extension Vmeta_LinkStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LINK_STATUS_DOWN"),
    1: .same(proto: "LINK_STATUS_UP"),
    2: .same(proto: "LINK_STATUS_RUNNING"),
    3: .same(proto: "LINK_STATUS_READY"),
    4: .same(proto: "LINK_STATUS_CONNECTING"),
    5: .same(proto: "LINK_STATUS_ERROR"),
  ]
}

extension Vmeta_ThermalCalibrationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TCS_DONE"),
    1: .same(proto: "TCS_REQUESTED"),
    2: .same(proto: "TCS_IN_PROGRESS"),
  ]
}

extension Vmeta_Quaternion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Quaternion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "w"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
    4: .same(proto: "z"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.w) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.w != 0 {
      try visitor.visitSingularFloatField(value: self.w, fieldNumber: 1)
    }
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 2)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 3)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_Quaternion, rhs: Vmeta_Quaternion) -> Bool {
    if lhs.w != rhs.w {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .standard(proto: "altitude_wgs84ellipsoid"),
    7: .standard(proto: "altitude_egm96amsl"),
    5: .standard(proto: "horizontal_accuracy"),
    6: .standard(proto: "vertical_accuracy"),
    4: .standard(proto: "sv_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.altitudeWgs84Ellipsoid) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.svCount) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.horizontalAccuracy) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.verticalAccuracy) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.altitudeEgm96Amsl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    if self.altitudeWgs84Ellipsoid != 0 {
      try visitor.visitSingularDoubleField(value: self.altitudeWgs84Ellipsoid, fieldNumber: 3)
    }
    if self.svCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.svCount, fieldNumber: 4)
    }
    if self.horizontalAccuracy != 0 {
      try visitor.visitSingularFloatField(value: self.horizontalAccuracy, fieldNumber: 5)
    }
    if self.verticalAccuracy != 0 {
      try visitor.visitSingularFloatField(value: self.verticalAccuracy, fieldNumber: 6)
    }
    if self.altitudeEgm96Amsl != 0 {
      try visitor.visitSingularDoubleField(value: self.altitudeEgm96Amsl, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_Location, rhs: Vmeta_Location) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.altitudeWgs84Ellipsoid != rhs.altitudeWgs84Ellipsoid {return false}
    if lhs.altitudeEgm96Amsl != rhs.altitudeEgm96Amsl {return false}
    if lhs.horizontalAccuracy != rhs.horizontalAccuracy {return false}
    if lhs.verticalAccuracy != rhs.verticalAccuracy {return false}
    if lhs.svCount != rhs.svCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_Vector2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vector2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_Vector2, rhs: Vmeta_Vector2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_Vector3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vector3"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_Vector3, rhs: Vmeta_Vector3) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_NED: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NED"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "north"),
    2: .same(proto: "east"),
    3: .same(proto: "down"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.north) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.east) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.down) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.north != 0 {
      try visitor.visitSingularFloatField(value: self.north, fieldNumber: 1)
    }
    if self.east != 0 {
      try visitor.visitSingularFloatField(value: self.east, fieldNumber: 2)
    }
    if self.down != 0 {
      try visitor.visitSingularFloatField(value: self.down, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_NED, rhs: Vmeta_NED) -> Bool {
    if lhs.north != rhs.north {return false}
    if lhs.east != rhs.east {return false}
    if lhs.down != rhs.down {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_BoundingBox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoundingBox"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
    5: .standard(proto: "object_class"),
    6: .same(proto: "confidence"),
    7: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.width) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.height) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.objectClass) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.confidence) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 4)
    }
    if self.objectClass != .tcPerson {
      try visitor.visitSingularEnumField(value: self.objectClass, fieldNumber: 5)
    }
    if self.confidence != 0 {
      try visitor.visitSingularFloatField(value: self.confidence, fieldNumber: 6)
    }
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_BoundingBox, rhs: Vmeta_BoundingBox) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.objectClass != rhs.objectClass {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_ThermalSpot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThermalSpot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "temp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.temp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.temp != 0 {
      try visitor.visitSingularFloatField(value: self.temp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_ThermalSpot, rhs: Vmeta_ThermalSpot) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.temp != rhs.temp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_DroneMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DroneMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quat"),
    2: .same(proto: "location"),
    3: .standard(proto: "ground_distance"),
    9: .same(proto: "position"),
    10: .standard(proto: "local_position"),
    4: .same(proto: "speed"),
    5: .standard(proto: "battery_percentage"),
    7: .standard(proto: "flying_state"),
    11: .standard(proto: "animation_in_progress"),
    12: .standard(proto: "piloting_mode"),
  ]

  fileprivate class _StorageClass {
    var _quat: Vmeta_Quaternion? = nil
    var _location: Vmeta_Location? = nil
    var _groundDistance: Double = 0
    var _position: Vmeta_NED? = nil
    var _localPosition: Vmeta_Vector3? = nil
    var _speed: Vmeta_NED? = nil
    var _batteryPercentage: Int32 = 0
    var _flyingState: Vmeta_FlyingState = .fsLanded
    var _animationInProgress: Bool = false
    var _pilotingMode: Vmeta_PilotingMode = .pmUnknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _quat = source._quat
      _location = source._location
      _groundDistance = source._groundDistance
      _position = source._position
      _localPosition = source._localPosition
      _speed = source._speed
      _batteryPercentage = source._batteryPercentage
      _flyingState = source._flyingState
      _animationInProgress = source._animationInProgress
      _pilotingMode = source._pilotingMode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._quat) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._groundDistance) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._speed) }()
        case 5: try { try decoder.decodeSingularSInt32Field(value: &_storage._batteryPercentage) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._flyingState) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._position) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._localPosition) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._animationInProgress) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._pilotingMode) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._quat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._groundDistance != 0 {
        try visitor.visitSingularDoubleField(value: _storage._groundDistance, fieldNumber: 3)
      }
      try { if let v = _storage._speed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._batteryPercentage != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._batteryPercentage, fieldNumber: 5)
      }
      if _storage._flyingState != .fsLanded {
        try visitor.visitSingularEnumField(value: _storage._flyingState, fieldNumber: 7)
      }
      try { if let v = _storage._position {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._localPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._animationInProgress != false {
        try visitor.visitSingularBoolField(value: _storage._animationInProgress, fieldNumber: 11)
      }
      if _storage._pilotingMode != .pmUnknown {
        try visitor.visitSingularEnumField(value: _storage._pilotingMode, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_DroneMetadata, rhs: Vmeta_DroneMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._quat != rhs_storage._quat {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._groundDistance != rhs_storage._groundDistance {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._localPosition != rhs_storage._localPosition {return false}
        if _storage._speed != rhs_storage._speed {return false}
        if _storage._batteryPercentage != rhs_storage._batteryPercentage {return false}
        if _storage._flyingState != rhs_storage._flyingState {return false}
        if _storage._animationInProgress != rhs_storage._animationInProgress {return false}
        if _storage._pilotingMode != rhs_storage._pilotingMode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_CameraMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CameraMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    10: .standard(proto: "utc_timestamp"),
    11: .standard(proto: "utc_timestamp_accuracy"),
    2: .standard(proto: "base_quat"),
    3: .same(proto: "quat"),
    12: .standard(proto: "local_position"),
    13: .same(proto: "location"),
    14: .standard(proto: "principal_point"),
    4: .standard(proto: "exposure_time"),
    5: .standard(proto: "iso_gain"),
    6: .standard(proto: "awb_r_gain"),
    7: .standard(proto: "awb_b_gain"),
    8: .same(proto: "hfov"),
    9: .same(proto: "vfov"),
  ]

  fileprivate class _StorageClass {
    var _timestamp: UInt64 = 0
    var _utcTimestamp: UInt64 = 0
    var _utcTimestampAccuracy: UInt32 = 0
    var _baseQuat: Vmeta_Quaternion? = nil
    var _quat: Vmeta_Quaternion? = nil
    var _localPosition: Vmeta_Vector3? = nil
    var _location: Vmeta_Location? = nil
    var _principalPoint: Vmeta_Vector2? = nil
    var _exposureTime: Float = 0
    var _isoGain: UInt32 = 0
    var _awbRGain: Float = 0
    var _awbBGain: Float = 0
    var _hfov: Float = 0
    var _vfov: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timestamp = source._timestamp
      _utcTimestamp = source._utcTimestamp
      _utcTimestampAccuracy = source._utcTimestampAccuracy
      _baseQuat = source._baseQuat
      _quat = source._quat
      _localPosition = source._localPosition
      _location = source._location
      _principalPoint = source._principalPoint
      _exposureTime = source._exposureTime
      _isoGain = source._isoGain
      _awbRGain = source._awbRGain
      _awbBGain = source._awbBGain
      _hfov = source._hfov
      _vfov = source._vfov
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._baseQuat) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._quat) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._exposureTime) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._isoGain) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._awbRGain) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._awbBGain) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._hfov) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._vfov) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._utcTimestamp) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._utcTimestampAccuracy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._localPosition) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._principalPoint) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._timestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timestamp, fieldNumber: 1)
      }
      try { if let v = _storage._baseQuat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._quat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._exposureTime != 0 {
        try visitor.visitSingularFloatField(value: _storage._exposureTime, fieldNumber: 4)
      }
      if _storage._isoGain != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._isoGain, fieldNumber: 5)
      }
      if _storage._awbRGain != 0 {
        try visitor.visitSingularFloatField(value: _storage._awbRGain, fieldNumber: 6)
      }
      if _storage._awbBGain != 0 {
        try visitor.visitSingularFloatField(value: _storage._awbBGain, fieldNumber: 7)
      }
      if _storage._hfov != 0 {
        try visitor.visitSingularFloatField(value: _storage._hfov, fieldNumber: 8)
      }
      if _storage._vfov != 0 {
        try visitor.visitSingularFloatField(value: _storage._vfov, fieldNumber: 9)
      }
      if _storage._utcTimestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._utcTimestamp, fieldNumber: 10)
      }
      if _storage._utcTimestampAccuracy != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._utcTimestampAccuracy, fieldNumber: 11)
      }
      try { if let v = _storage._localPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._principalPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_CameraMetadata, rhs: Vmeta_CameraMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._utcTimestamp != rhs_storage._utcTimestamp {return false}
        if _storage._utcTimestampAccuracy != rhs_storage._utcTimestampAccuracy {return false}
        if _storage._baseQuat != rhs_storage._baseQuat {return false}
        if _storage._quat != rhs_storage._quat {return false}
        if _storage._localPosition != rhs_storage._localPosition {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._principalPoint != rhs_storage._principalPoint {return false}
        if _storage._exposureTime != rhs_storage._exposureTime {return false}
        if _storage._isoGain != rhs_storage._isoGain {return false}
        if _storage._awbRGain != rhs_storage._awbRGain {return false}
        if _storage._awbBGain != rhs_storage._awbBGain {return false}
        if _storage._hfov != rhs_storage._hfov {return false}
        if _storage._vfov != rhs_storage._vfov {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_TrackingProposalMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrackingProposalMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposals"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.proposals) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.proposals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.proposals, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_TrackingProposalMetadata, rhs: Vmeta_TrackingProposalMetadata) -> Bool {
    if lhs.proposals != rhs.proposals {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_TrackingMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrackingMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "quality"),
    4: .same(proto: "state"),
    5: .same(proto: "cookie"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.quality) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.cookie) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if self.quality != 0 {
      try visitor.visitSingularUInt32Field(value: self.quality, fieldNumber: 3)
    }
    if self.state != .tsTracking {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if self.cookie != 0 {
      try visitor.visitSingularUInt32Field(value: self.cookie, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_TrackingMetadata, rhs: Vmeta_TrackingMetadata) -> Bool {
    if lhs._target != rhs._target {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.state != rhs.state {return false}
    if lhs.cookie != rhs.cookie {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_AutomationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutomationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .standard(proto: "target_location"),
    3: .standard(proto: "follow_me"),
    4: .standard(proto: "lookat_me"),
    5: .standard(proto: "angle_locked"),
    6: .same(proto: "animation"),
  ]

  fileprivate class _StorageClass {
    var _destination: Vmeta_Location? = nil
    var _targetLocation: Vmeta_Location? = nil
    var _followMe: Bool = false
    var _lookatMe: Bool = false
    var _angleLocked: Bool = false
    var _animation: Vmeta_Animation = .animNone

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _destination = source._destination
      _targetLocation = source._targetLocation
      _followMe = source._followMe
      _lookatMe = source._lookatMe
      _angleLocked = source._angleLocked
      _animation = source._animation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._destination) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._targetLocation) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._followMe) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._lookatMe) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._angleLocked) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._animation) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._destination {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._targetLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._followMe != false {
        try visitor.visitSingularBoolField(value: _storage._followMe, fieldNumber: 3)
      }
      if _storage._lookatMe != false {
        try visitor.visitSingularBoolField(value: _storage._lookatMe, fieldNumber: 4)
      }
      if _storage._angleLocked != false {
        try visitor.visitSingularBoolField(value: _storage._angleLocked, fieldNumber: 5)
      }
      if _storage._animation != .animNone {
        try visitor.visitSingularEnumField(value: _storage._animation, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_AutomationMetadata, rhs: Vmeta_AutomationMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._targetLocation != rhs_storage._targetLocation {return false}
        if _storage._followMe != rhs_storage._followMe {return false}
        if _storage._lookatMe != rhs_storage._lookatMe {return false}
        if _storage._angleLocked != rhs_storage._angleLocked {return false}
        if _storage._animation != rhs_storage._animation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_WifiLinkMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WifiLinkMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "goodput"),
    2: .same(proto: "quality"),
    3: .same(proto: "rssi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.goodput) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.quality) }()
      case 3: try { try decoder.decodeSingularSInt32Field(value: &self.rssi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.goodput != 0 {
      try visitor.visitSingularUInt32Field(value: self.goodput, fieldNumber: 1)
    }
    if self.quality != 0 {
      try visitor.visitSingularUInt32Field(value: self.quality, fieldNumber: 2)
    }
    if self.rssi != 0 {
      try visitor.visitSingularSInt32Field(value: self.rssi, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_WifiLinkMetadata, rhs: Vmeta_WifiLinkMetadata) -> Bool {
    if lhs.goodput != rhs.goodput {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_StarfishLinkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StarfishLinkInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "quality"),
    4: .same(proto: "active"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.quality) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.status != .down {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.quality != 0 {
      try visitor.visitSingularInt32Field(value: self.quality, fieldNumber: 3)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_StarfishLinkInfo, rhs: Vmeta_StarfishLinkInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.status != rhs.status {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.active != rhs.active {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_StarfishLinkMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StarfishLinkMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "links"),
    2: .same(proto: "quality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.quality) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 1)
    }
    if self.quality != 0 {
      try visitor.visitSingularInt32Field(value: self.quality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_StarfishLinkMetadata, rhs: Vmeta_StarfishLinkMetadata) -> Bool {
    if lhs.links != rhs.links {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_LinkMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LinkMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wifi"),
    2: .same(proto: "starfish"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Vmeta_WifiLinkMetadata?
        var hadOneofValue = false
        if let current = self.`protocol` {
          hadOneofValue = true
          if case .wifi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.`protocol` = .wifi(v)
        }
      }()
      case 2: try {
        var v: Vmeta_StarfishLinkMetadata?
        var hadOneofValue = false
        if let current = self.`protocol` {
          hadOneofValue = true
          if case .starfish(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.`protocol` = .starfish(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.`protocol` {
    case .wifi?: try {
      guard case .wifi(let v)? = self.`protocol` else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .starfish?: try {
      guard case .starfish(let v)? = self.`protocol` else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_LinkMetadata, rhs: Vmeta_LinkMetadata) -> Bool {
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_ThermalMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThermalMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "calibration_state"),
    2: .same(proto: "min"),
    3: .same(proto: "max"),
    4: .same(proto: "probe"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.calibrationState) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._min) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._max) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._probe) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.calibrationState != .tcsDone {
      try visitor.visitSingularEnumField(value: self.calibrationState, fieldNumber: 1)
    }
    try { if let v = self._min {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._max {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._probe {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_ThermalMetadata, rhs: Vmeta_ThermalMetadata) -> Bool {
    if lhs.calibrationState != rhs.calibrationState {return false}
    if lhs._min != rhs._min {return false}
    if lhs._max != rhs._max {return false}
    if lhs._probe != rhs._probe {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_LFICMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LFICMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "location"),
    4: .standard(proto: "grid_precision"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.gridPrecision) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.gridPrecision != 0 {
      try visitor.visitSingularDoubleField(value: self.gridPrecision, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_LFICMetadata, rhs: Vmeta_LFICMetadata) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs._location != rhs._location {return false}
    if lhs.gridPrecision != rhs.gridPrecision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vmeta_TimedMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimedMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "drone"),
    2: .same(proto: "camera"),
    3: .same(proto: "links"),
    4: .same(proto: "tracking"),
    5: .same(proto: "proposal"),
    6: .same(proto: "automation"),
    7: .same(proto: "thermal"),
    8: .same(proto: "lfic"),
  ]

  fileprivate class _StorageClass {
    var _drone: Vmeta_DroneMetadata? = nil
    var _camera: Vmeta_CameraMetadata? = nil
    var _links: [Vmeta_LinkMetadata] = []
    var _tracking: Vmeta_TrackingMetadata? = nil
    var _proposal: Vmeta_TrackingProposalMetadata? = nil
    var _automation: Vmeta_AutomationMetadata? = nil
    var _thermal: Vmeta_ThermalMetadata? = nil
    var _lfic: Vmeta_LFICMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _drone = source._drone
      _camera = source._camera
      _links = source._links
      _tracking = source._tracking
      _proposal = source._proposal
      _automation = source._automation
      _thermal = source._thermal
      _lfic = source._lfic
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._drone) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._camera) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._links) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._tracking) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._proposal) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._automation) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._thermal) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lfic) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._drone {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._camera {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._links.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._links, fieldNumber: 3)
      }
      try { if let v = _storage._tracking {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._proposal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._automation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._thermal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._lfic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vmeta_TimedMetadata, rhs: Vmeta_TimedMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._drone != rhs_storage._drone {return false}
        if _storage._camera != rhs_storage._camera {return false}
        if _storage._links != rhs_storage._links {return false}
        if _storage._tracking != rhs_storage._tracking {return false}
        if _storage._proposal != rhs_storage._proposal {return false}
        if _storage._automation != rhs_storage._automation {return false}
        if _storage._thermal != rhs_storage._thermal {return false}
        if _storage._lfic != rhs_storage._lfic {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
